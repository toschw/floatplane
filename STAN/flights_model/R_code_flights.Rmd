---
title: "StanAnalysis"
author: "Tobias Schwoerer"
date: "March 8, 2019"
output: html_document
editor_options: 
  chunk_output_type: console
---
#Hierarchical model using Stan for estimating the probability of infection for uninfected lake j  
## Code by Tobias Schwoerer, 03/08/2019 with assistance from Roman Dial
## Useful references: Gelman et al. 2013. Bayesian Data Analysis 3rd ed. , Carpenter et al. 2016. Stan: A probabilistic programming language. Journal of Statistical Software

##STEP 1
#read in the data from floatplanedata3.csv which was imported using RStudio's dataset import feature
```{r}
data <-  read.csv("STAN/floatplanedata4.csv")
J <- nrow(data)
n <- data$flights
y <- data$eflights
```

##STEP2#  run Stan
```{r}
library(rstan)
rstan_options(auto_write = TRUE)
Sys.setenv(LOCAL_CPPFLAGS = '-march=native')
options(mc.cores = parallel::detectCores())
datafit1 <- stan(file="STAN/flights_model/flights_model.stan",data=c("J","y","n"), iter = 10000, chains = 4,control=list(adapt_delta=0.8, max_treedepth =10))
```

##STEP3# Save data fit file, and save posterior summary statistics as csv files, (remove # in each of the following lines if you want to do this this)
```{r}  
#Saving beta-binomial model output
datafit.df <- as.data.frame(datafit1)
write.csv(datafit.df, file = "STAN/flights_model/datafit.csv",  quote = TRUE, sep = " ",
          eol = "\n", na = "NA", dec = ".", row.names = FALSE,
          col.names = TRUE, qmethod = c("escape", "double"),
          fileEncoding = "")
#Save posterior summary statistics
  fit_summary <- summary(datafit1)
  fit_summary.df <- as.data.frame(fit_summary$summary)
  write.csv(fit_summary.df, file = "STAN/flights_model/fit_summary1.csv",  quote = TRUE, sep = " ",eol = "\n", na = "NA", dec = ".", row.names = TRUE, col.names = TRUE, qmethod = c("escape", "double"), fileEncoding = "")
```

##STEP4# Presenting model results and creating figures
Posterior summary for just Martin lake (highest theta of all 727 destinations) and the average
```{r}
print(datafit1,pars=c("theta[322]","avg"))
```

Scatter plot of observed versus estimated  using the csv generated from STEP3 
```{r}
library(plyr)
library(ggplot2)
sdata <- fit_summary.df
##renaming columns of above data frame
names(sdata)[4:8] <- c("perc3","perc25","perc50","perc75","perc97")

Figure2.3 <-  ggplot(sdata, aes(x=sdata$ratio,y=sdata$X50.)) +
  geom_pointrange(aes(ymin=sdata$perc3, ymax=sdata$perc97)) + 
  xlab("observed AIS introduction rate")+ ylab("95% posterior interval for theta(j)") +
  ylim(0,1)+ xlim(0,1) + geom_jitter(height=0,width=0.1)+ geom_abline(intercept = 0, slope = 1,colour='red')+
  theme(axis.title.x = element_text(face="bold", colour="#000000", size=15),
        axis.text.x  = element_text(face="bold", angle=0, vjust=0.5, size=15)) +
  theme(axis.title.y = element_text(face="bold", colour="#000000", size=15),
        axis.text.y  = element_text(face="bold", angle=360, vjust=0.5, size=15))+
  theme(panel.background = element_rect(fill = 'white', colour="black"))
Figure2.3 <- Figure2.3 + geom_point() + geom_text(data=subset(sdata,labels==1),aes(x=sdata$ratio,y=sdata$X50.,label=names))
Figure2.3
```

# Figure: Posterior probability distributions for elodea-infested destination lakes and suspected eldoea-infested lakes
```{r}
library(ggplot2)
library(rstan)
fig <- plot(datafit1, show_density = TRUE, pars=c("theta[321]","theta[322]","theta[324]","theta[376]","theta[518]","theta[300]","theta[309]","theta[376]","theta[347]","theta[570]","theta[10]",'theta[513]',"avg"), ci_level = 0.5, fill_color = "#99d8c9")
chvector <- character(length=9)
chvector <- c("Average","Lockwood Lake","Fish Lakes", "Finger Lake","Lake Hood","Daniels Lake","Stormy Lake","Alexander Lake","Sucker Lake","McKinley Lake","Martin Lake","Bering Lake")
fig <- fig + scale_y_continuous(labels=chvector[1:12],breaks=1:12) + ggtitle("Introduction rate posteriors") + labs(x="data")
fig 
```

## STEP5#  Model checking
# Check 1
traceplots showing convergence
```{r}
Figure2.6 <- traceplot(datafit1, pars = c("theta[322]","theta[324]","theta[347]","avg"), inc_warmup = TRUE, nrow = 9)
levels(Figure2.6$data$parameter)[1] <- "Martin Lake"
levels(Figure2.6$data$parameter)[2] <- "McKinley Lake"
levels(Figure2.6$data$parameter)[3] <- "Lake Hood"
levels(Figure2.6$data$parameter)[4] <- "Average"
Figure2.6 <- Figure2.6 + xlab("iteration") + ylab("posterior for theta(j)")
Figure2.6
```

# Check 2
Accessing the posterior simulations and checking sampling difficulties, as in Gelman text p.593-4
```{r}
data_sims <- extract(datafit1, permuted=TRUE)
p1 <- hist(data_sims$lambda)
p2 <- hist(data_sims$kappa)
p3 <- hist(data_sims$theta)
p4 <- hist(data_sims$alpha)
p5 <- hist(data_sims$beta)

par(mfrow=c(3,2))
hist(data_sims$lambda)
hist(data_sims$kappa)
hist(data_sims$theta)
hist(data_sims$alpha)
hist(data_sims$beta)

```

#Check 3
posterior predictive simulations and model check, Replicated data for existing destinations, Gelman p593
```{r}
n_sims <- length(data_sims$lp__)
y_rep <- array(NA,c(n_sims,J))
for (s in 1:n_sims){
  y_rep[s,] <- rbinom(J,n_sims,data_sims$theta[s,])
}

par(mfrow=c(5,4),mar=c(4,4,2,2))
hist(y,xlab="",main="y")
for (s in 1:19)
  hist(y_rep[s,], xlab="",main=paste("y_rep",s))

#numerical test statistic using max (A) and min (B) number of pilots from elodea-infested floatplane bases
#For generating Figure2.7A set y_sort[1]-y_sort[2], for Figure2.7B set y_sort[726]-y_sort[727]

test <- function (y){
  y_sort <- sort(y,decreasing=TRUE)
  return (y_sort[1]-y_sort[2])
}
t_y <- test(y)
t_rep <- rep(NA,n_sims)
for (s in 1:n_sims)
  t_rep[s] <- test(y_rep[s,])

  #Printing tail area probability (p-value) and generating histogram (see Gelman p. 594)
par(mfrow=c(1,1))
cat("T(y)=",round(t_y,1), " and T(y_rep) has mean",round(mean(t_rep),1),"and sd", round(sd(t_rep),1),"\nPr (T(y_rep)> T(y))=", round(mean(t_rep>t_y),2), "\n")
Figure2.7 <- hist(t_rep, xlim=range(t_y,t_rep), xlab="T(y_rep)", main="" )
lines (rep(t_y,2),c(0,1e6))
text (t_y, .9*max(Figure2.7$count),"T(y)", adj=0)
```

#Check  4
Replicating new data
Generating replicated data for 727 new lakes 
```{r}
theta_rep <- array(NA,c(n_sims,J))
y_rep <- array(NA,c(n_sims,J))
for (s in 1:n_sims){
  theta_rep[s,] <- rbeta(J,data_sims$alpha[s],data_sims$beta[s])
  y_rep[s,] <- rbinom(J,n_sims,theta_rep[s,])
}

 #displaying replicated data
par(mfrow=c(5,4),mar=c(4,4,2,2))
hist(y/n,xlab="",main="theta")
for (s in 1:19)
  hist(theta_rep[s,], xlab="",main=paste("theta_rep",s))

 # calculating mean and SD for replicated new data
theta_mean <- mean(theta_rep)
theta_mean
theta_sd <- sd(theta_rep)
theta_sd
```

Result from the above is:
theta_mean = 0.2468845
theta_sd = 0.3655449


# Check 5
Model comparison using aic, e.g. could compare constraint model(lambda>0.5) with unconstrained model. 
Note, would need to run alternative model (e.g. with lambda constraint),then reading in that datafit object as datafit2 to have consisten code below. 
```{r}
library(loo)
log_lik1 <- extract_log_lik(datafit1,parameter_name = "lp__")
log_lik2 <- extract_log_lik(datafit2,parameter_name = "lp__")
(waic1 <- waic(log_lik1))
(waic2 <- waic(log_lik2))
print(compare(waic1, waic2), digits = 2)

library(loo)
log_lik1 <- extract_log_lik(datafit1,parameter_name = "lp__") # see ?extract_log_lik
loo1 <- loo(log_lik1)
print(loo1, digits = 3)

log_lik2 <- extract_log_lik(datafit2,parameter_name = "lp__")
(loo2 <- loo(log_lik2))
compare(loo1, loo2)

#scatter plot theta_rep on y-axis, data y/n on x-axis
MLEp <- y/n
jMLEp <- jitter(MLEp)
mintheta <- min(data_sims$theta[J,])

plot(jMLEp,mean(theta_rep[s,]),xlim=c(0.,1),ylim=c(0.,1))
abline(a=0,b=1)

test<-mean(data_sims$theta[1:2000,1:8])
test
for (j in 1:J){
  test[j,] <-mean(data_sims$theta[1:2000,j:8]) 
  }
test[J,]
```

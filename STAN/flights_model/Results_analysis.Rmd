---
title: "STAN_results"
author: "Tobias Schwoerer"
date: "March 25, 2019"
output: html_document
editor_options: 
  chunk_output_type: console
---

This code was used to prepare a .csv result file for further ArcGIS data visualization of the datafit.csv results file generated by the 
flights ration model that I ran in STAN.

```{r}
library(dplyr)
library(tidyr)
library(data.table)
library(purrr)
library(jsonlite)
library(geojson)
library(leaflet)
library(ggplot2)
library(RColorBrewer)
library(leaflet.minicharts)

#setwd("D:/ANALYSIS_R/floatplane")
data <- read.csv("STAN/flights_model/datafit.csv")

#subsetting data
draws <- select(data,2:728)
abavg <- select(data,734:1460 ) 
ranks <- select(data,1461:2187)
```

Creating a reference table with destination-specific information
```{r}
#importing reference table for destination information and association to theta[id]
ref <- read.csv("Data/Destinations091916_4.csv", stringsAsFactors = FALSE)

#cleaning up come unnecessary columns
keepCol <- c("Destina_11","WithinNPS_","WithinRefu","HUC8","Suitab","HUC6","Name","GMU","UniqueID","Fetch_m","ElevMIN","ElevMAX","Dest1Lat","Dest2Long","DestName","X25th","median","X75th","medianrank","Dest_sqkm","modelID")
ref <- dplyr::select(ref, keepCol)

#there are multiple lat long pairs possible for each UniqueID, but since the analysis is by destination waterbody (among all 727 identified) we chose just one lat long per UniqueID. extracting unique records so each destination is represented in each row
#So we used 
ref = ref[!duplicated(ref$UniqueID),]
#Instead of:
#IDs <- unique(ref$UniqueID)
#ref <- subset(ref, UniqueID %in% IDs)

#renaming columns
setnames(ref, old=c("Destina_11","WithinNPS_","Name","Dest1Lat","Dest2Long"), new=c("DestType", "WithinNPS","RegionName","Lat","Long"))
#ordering by modelID number shown in [] brackets
ref$LakeID <- gsub(".*\\[|\\]", "", ref$modelID) 
ref$LakeID <- as.numeric(ref$LakeID)
              
ref = ref[order(ref[,'LakeID']),]
```

25th, median, 75th percentile
```{r}
library(tidyverse)
drawsR <- draws%>%
    summarise_all(funs(list(quantile(., probs = c(0.25, 0.5, 0.75))))) %>%
    unnest %>%
    transpose %>%
    setNames(., c('p25th', 'p50th', 'p75th')) %>%
    map_df(unlist) %>%
    bind_cols(data.frame(vars = names(draws)), .)
setnames(drawsR, old=c("vars"),new=c("vars3"))
```

variance of the posterior
```{r}
varR <- draws%>%
  summarise_each(var)%>%
    unnest %>%
    transpose %>%
    setNames(., c('variance')) %>%
    map_df(unlist) %>%
    bind_cols(data.frame(vars = names(draws)), .)
setnames(varR, old=c("vars"),new=c("vars4"))
```

Subset of destinations with above average probability of infestation through floatplanes
```{r}
abavgR <- abavg%>%
    summarise_each(mean)%>%
    unnest %>%
    transpose %>%
    setNames(., c('mean_abavg')) %>%
    map_df(unlist) %>%
    bind_cols(data.frame(vars = names(abavg)), .)
setnames(abavgR, old=c("vars"),new=c("vars1"))
```

Risk rank among the 727 identified waterbodies
```{r}
ranksR <- ranks%>%
    summarise_each(mean)%>%
    unnest %>%
    transpose %>%
    setNames(., c('mean_rank')) %>%
    map_df(unlist) %>%
    bind_cols(data.frame(vars = names(ranks)), .)
setnames(ranksR, old=c("vars"),new=c("vars2"))
```

Combining results and adding destination specific information
```{r}
results <- cbind(drawsR, abavgR,ranksR,varR,ref)
#dropping a few unnecessary columns

results <- results%>%
  select(-vars1, -vars2, -vars3, -vars4)
```

Comparing the risk ranks between previous analysis using pilot ratios vs. flight ratios
```{r}
#medianrank is from previous pilot ratios, mean_rank is the risk rank based on flight frequencies
with(results,(plot(medianrank, mean_rank,xlim=c(0,727), ylim=c(0,727),xlab="ranks pilot-ratio-model",
ylab="ranks flight-ratio-model")))
abline(a=0,b=1, col="blue")
title("Comparing pilot ratio to flight ratio models")
```

Dropping pilot ratio model results from results, writing to csv file
```{r}
results2 <- results%>%
  select(-X25th, -median, -X75th, -medianrank)
results2$inv_variance = 1/results2$variance
write.csv(results2, file="D:/Dropbox/DATA/2015_Schwoerer_floatplane_survey/STANresults.csv")
```

graphing and mapping
```{r}
#creating subset of destinations with a median prob >0.8
lakes <- subset(results2, p50th>0.8)
# Create a continuous palette function
pal <- colorNumeric(
  palette = "Reds",
  domain = lakes$p50th)
#Interactive layer display
clickMap1 <- leaflet(lakes, width = "100%", height = 1000) %>%
  setView(-147.3, 62.0, zoom = 5)%>%
  #Base groups
  addTiles(group = "OpenStreetMap") %>%
  addProviderTiles(providers$Esri.WorldTopoMap, group = "Esri Topo")%>%
  addProviderTiles(providers$Esri.WorldImagery, group = "Esri Image")%>%
  #Overlay groups
  addCircleMarkers(lat = ~Lat, lng = ~Long, ~p50th, radius = ~inv_variance/10000, stroke=F,  
                   color= ~pal(p50th), fillOpacity = 1, weight = 25)%>%
    #Layers control
  addLayersControl(
    baseGroups = c("Esri Topo", "Esri Image","OpenStreetMap")
      )%>%
  addLegend("topright",values= ~p50th, pal=pal, title="median probability")
clickMap1
```

Still need to include elodea variable in data setup above for lakes that are known to have elodea
Validation of the model with elodea presence
```{r}
c1 <- read.csv("C:/Users/Toby/Dropbox/DATA/2015_Schwoerer_floatplane_survey/STANresults.csv", stringsAsFactors = F)
with(test, plot(p50th, elodea))

elodeaLakes <- c1%>%
  group_by(elodea)%>%
    summarise(countHigh = sum(ifelse(p50th>0.5,1,0)),
              countLow = sum(ifelse(p50th<=0.5,1,0))) 
              
              
              
	  t1t = sum( ifelse( c1 == "t", v1, 0 ) )
```
